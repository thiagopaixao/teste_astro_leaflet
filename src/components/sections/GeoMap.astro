---
interface Props {
  title: string;
  content: string;
  latitude: number;
  longitude: number;
  zoom: number;
  geojsons?: { geojson: string }[];
  id: string;
  typelayer: string;
}

const { title, content, latitude, longitude, zoom, geojsons, id, typelayer } = Astro.props;
---

<section class="relative w-full h-screen sticky top-0">
  <div class="absolute inset-0 z-10 bg-black bg-opacity-50 flex flex-col justify-center items-center text-white p-4">
    <h2 class="text-3xl font-bold mb-4">{title}</h2>
    <div class="prose max-w-none mb-4 text-white" set:html={content} />
  </div>
  <div id={id} class="absolute inset-0 geo-map" data-latitude={latitude} data-longitude={longitude} data-zoom={zoom} data-geojsons={JSON.stringify(geojsons?.map(g => g.geojson))} data-typelayer={typelayer}></div>
</section>
<div class="h-screen"></div> <!-- Espaço adicional para permitir o scroll -->

<style>
  .prose :global(*) {
    color: white;
  }
</style>

<script>
  import L from 'leaflet';
  import 'leaflet/dist/leaflet.css';

  function initMap() {
    const mapElements = document.querySelectorAll('.geo-map');
    mapElements.forEach((mapElement) => {
      if (!mapElement) return;

      const latitude = Number(mapElement.dataset.latitude);
      const longitude = Number(mapElement.dataset.longitude);
      const zoom = Number(mapElement.dataset.zoom);
      const geojsonsString = mapElement.dataset.geojsons;

      const map = L.map(mapElement.id, {
        zoomControl: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        touchZoom: false,
        boxZoom: false,
        keyboard: false,
        zoomSnap: 0,
        zoomDelta: 0,
        dragging: false,
        minZoom: zoom,
        maxZoom: zoom
      }).setView([latitude, longitude], zoom);

      const mapTypes = {
        map: {
          url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        },
        topology: {
          url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
          attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        },
        satellite: {
          url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
          attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        }
      };

      const typelayer = mapElement.dataset.typelayer || 'map';
      const selectedMapType = mapTypes[typelayer];

      console.log(`Map ${mapElement.id} initialized with type: ${typelayer}`);

      // Adiciona um controle de camadas para alternar entre os tipos de mapa
      // Cria todas as camadas
      const baseLayers = {
        "Mapa": L.tileLayer(mapTypes.map.url, { attribution: mapTypes.map.attribution }),
        "Topografia": L.tileLayer(mapTypes.topology.url, { attribution: mapTypes.topology.attribution }),
        "Satélite": L.tileLayer(mapTypes.satellite.url, { attribution: mapTypes.satellite.attribution })
      };

      // Determina qual camada deve ser adicionada por padrão
      const defaultLayer = typelayer === 'map' ? "Mapa" : typelayer === 'topology' ? "Topografia" : "Satélite";

      // Adiciona a camada padrão ao mapa
      baseLayers[defaultLayer].addTo(map);

      // Adiciona o controle de camadas, marcando a camada padrão como selecionada
      const layerControl = L.control.layers(baseLayers, null, { position: 'topright' }).addTo(map);

      // Marca a camada padrão como selecionada no controle de camadas
      Object.keys(baseLayers).forEach(layerName => {
        if (layerName === defaultLayer) {
          map.addLayer(baseLayers[layerName]);
        } else {
          map.removeLayer(baseLayers[layerName]);
        }
      });

      let geoJsonLayers = [];
      let currentLayerIndex = 0;
      let isAnimating = false;

      if (geojsonsString) {
        try {
          const geojsons = JSON.parse(geojsonsString);
          console.log('Parsed GeoJSONs:', geojsons);

          geoJsonLayers = geojsons.map(geojsonString => {
            try {
              const geojson = JSON.parse(geojsonString);
              console.log('Individual GeoJSON:', geojson);
              return L.geoJSON(geojson, {
                style: function (feature) {
                  return {
                    color: "#ff7800",
                    weight: 5,
                    opacity: 0.65
                  };
                },
                onEachFeature: function (feature, layer) {
                  if (feature.properties && feature.properties.popupContent) {
                    layer.bindPopup(feature.properties.popupContent);
                  }
                }
              });
            } catch (error) {
              console.error('Error parsing individual GeoJSON:', error);
              return null;
            }
          }).filter(layer => layer !== null);

          console.log('GeoJSON Layers:', geoJsonLayers);

          if (geoJsonLayers.length > 0) {
            geoJsonLayers[0].addTo(map);
            const group = L.featureGroup(geoJsonLayers);
            map.fitBounds(group.getBounds());
          }
        } catch (error) {
          console.error('Error parsing GeoJSONs:', error);
        }
      } else {
        console.log('No GeoJSONs found');
      }

      // Função para animar a transição entre camadas GeoJSON
      function animateToLayer(targetIndex) {
        if (geoJsonLayers.length <= 1 || isAnimating) return;

        isAnimating = true;

        // Remove a camada atual
        if (currentLayerIndex >= 0 && currentLayerIndex < geoJsonLayers.length) {
          map.removeLayer(geoJsonLayers[currentLayerIndex]);
        }

        // Adiciona a nova camada
        map.addLayer(geoJsonLayers[targetIndex]);

        // Ajusta a visualização para a nova camada
        map.fitBounds(geoJsonLayers[targetIndex].getBounds(), {
          animate: true,
          duration: 1,
          easeLinearity: 0.5,
          paddingTopLeft: [0, 0],
          paddingBottomRight: [0, 0]
        });

        currentLayerIndex = targetIndex;

        setTimeout(() => {
          isAnimating = false;
        }, 1000);
      }

      // Função para verificar o scroll e animar para a próxima ou anterior camada
      function checkScrollAndAnimate() {
        const mapRect = mapElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const scrollProgress = (viewportHeight - mapRect.top) / viewportHeight;

        if (scrollProgress >= 0 && scrollProgress <= 1) {
          const targetIndex = Math.min(Math.max(0, Math.floor(scrollProgress * geoJsonLayers.length)), geoJsonLayers.length - 1);
          if (targetIndex !== currentLayerIndex) {
            animateToLayer(targetIndex);
          }
        }
      }

      // Variável para armazenar a última posição de scroll
      let lastScrollTop = 0;

      // Adiciona o evento de scroll com throttle
      let ticking = false;
      window.addEventListener('scroll', function() {
        const st = window.pageYOffset || document.documentElement.scrollTop;
        if (!ticking) {
          window.requestAnimationFrame(function() {
            checkScrollAndAnimate();
            ticking = false;
          });
          ticking = true;
        }
        lastScrollTop = st <= 0 ? 0 : st; // Para navegadores móveis
      });

      // Função para manter sempre uma camada GeoJSON visível
      function ensureVisibleLayer() {
        if (geoJsonLayers.length > 0) {
          if (!map.hasLayer(geoJsonLayers[currentLayerIndex])) {
            map.addLayer(geoJsonLayers[currentLayerIndex]);
          }
        }
      }

      // Chama a função para garantir que uma camada esteja sempre visível
      ensureVisibleLayer();

      // Função para redimensionar o mapa
      function resizeMap() {
        map.invalidateSize();
      }

      // Redimensiona o mapa quando a janela é redimensionada
      window.addEventListener('resize', resizeMap);

      // Redimensiona o mapa após um curto atraso para garantir que todos os elementos estejam carregados
      setTimeout(resizeMap, 250);
    });
  }

  // Initialize the map when the DOM is fully loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMap);
  } else {
    initMap();
  }
</script>
