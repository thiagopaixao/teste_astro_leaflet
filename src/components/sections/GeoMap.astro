---
interface Props {
  title: string;
  content: string;
  latitude: number;
  longitude: number;
  zoom: number;
  geojsons?: { geojson: string }[];
  id: string;
  typelayer: string;
}

const { title, content, latitude, longitude, zoom, geojsons, id, typelayer } = Astro.props;
---

<section class="relative w-full h-screen">
  <div class="absolute inset-0 z-10 bg-black bg-opacity-50 flex flex-col justify-center items-center text-white p-4">
    <h2 class="text-3xl font-bold mb-4">{title}</h2>
    <div class="prose max-w-none mb-4 text-white" set:html={content} />
  </div>
  <div id={id} class="absolute inset-0 geo-map" data-latitude={latitude} data-longitude={longitude} data-zoom={zoom} data-geojsons={JSON.stringify(geojsons?.map(g => g.geojson))} data-typelayer={typelayer}></div>
</section>

<style>
  .prose :global(*) {
    color: white;
  }
</style>

<script>
  import L from 'leaflet';
  import 'leaflet/dist/leaflet.css';

  function initMap() {
    const mapElements = document.querySelectorAll('.geo-map');
    mapElements.forEach((mapElement) => {
      if (!mapElement) return;

      const latitude = Number(mapElement.dataset.latitude);
      const longitude = Number(mapElement.dataset.longitude);
      const zoom = Number(mapElement.dataset.zoom);
      const geojsonsString = mapElement.dataset.geojsons;

      const map = L.map(mapElement.id, {
        zoomControl: false,  // Desativa o controle de zoom padrão
        scrollWheelZoom: false,  // Desativa o zoom com a roda do mouse
        doubleClickZoom: false,  // Desativa o zoom com duplo clique
        touchZoom: false,  // Desativa o zoom com toque (para dispositivos móveis)
        boxZoom: false,  // Desativa o zoom com caixa de seleção
        keyboard: false,  // Desativa o zoom com teclado
        zoomSnap: 0,  // Desativa o snap de zoom
        zoomDelta: 0,  // Desativa o delta de zoom
        minZoom: zoom,  // Define o zoom mínimo como o zoom inicial
        maxZoom: zoom  // Define o zoom máximo como o zoom inicial
      }).setView([latitude, longitude], zoom);

      const mapTypes = {
        map: {
          url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        },
        topology: {
          url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
          attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        },
        satellite: {
          url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
          attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        }
      };

      const typelayer = mapElement.dataset.typelayer || 'map';
      const selectedMapType = mapTypes[typelayer];

      console.log(`Map ${mapElement.id} initialized with type: ${typelayer}`);

      // Adiciona um controle de camadas para alternar entre os tipos de mapa
      // Cria todas as camadas
      const baseLayers = {
        "Mapa": L.tileLayer(mapTypes.map.url, { attribution: mapTypes.map.attribution }),
        "Topografia": L.tileLayer(mapTypes.topology.url, { attribution: mapTypes.topology.attribution }),
        "Satélite": L.tileLayer(mapTypes.satellite.url, { attribution: mapTypes.satellite.attribution })
      };

      // Determina qual camada deve ser adicionada por padrão
      const defaultLayer = typelayer === 'map' ? "Mapa" : typelayer === 'topology' ? "Topografia" : "Satélite";

      // Adiciona a camada padrão ao mapa
      baseLayers[defaultLayer].addTo(map);

      // Adiciona o controle de camadas, marcando a camada padrão como selecionada
      const layerControl = L.control.layers(baseLayers, null, { position: 'topright' }).addTo(map);

      // Marca a camada padrão como selecionada no controle de camadas
      Object.keys(baseLayers).forEach(layerName => {
        if (layerName === defaultLayer) {
          map.addLayer(baseLayers[layerName]);
        } else {
          map.removeLayer(baseLayers[layerName]);
        }
      });

      // Adiciona um controle de zoom personalizado
      const zoomControl = L.control({position: 'topright'});
      zoomControl.onAdd = function(map) {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
        container.style.backgroundColor = 'white';
        container.style.padding = '5px';

        const zoomInButton = L.DomUtil.create('a', 'leaflet-control-zoom-in', container);
        zoomInButton.innerHTML = '+';
        zoomInButton.href = '#';
        zoomInButton.style.display = 'block';
        zoomInButton.style.textAlign = 'center';
        zoomInButton.style.fontWeight = 'bold';
        zoomInButton.style.fontSize = '18px';
        zoomInButton.style.textDecoration = 'none';
        zoomInButton.style.color = 'black';

        const zoomOutButton = L.DomUtil.create('a', 'leaflet-control-zoom-out', container);
        zoomOutButton.innerHTML = '−';
        zoomOutButton.href = '#';
        zoomOutButton.style.display = 'block';
        zoomOutButton.style.textAlign = 'center';
        zoomOutButton.style.fontWeight = 'bold';
        zoomOutButton.style.fontSize = '18px';
        zoomOutButton.style.textDecoration = 'none';
        zoomOutButton.style.color = 'black';

        L.DomEvent.on(zoomInButton, 'click', function(e) {
          e.preventDefault();
          map.setView(map.getCenter(), map.getZoom() + 1, {animate: true});
        });

        L.DomEvent.on(zoomOutButton, 'click', function(e) {
          e.preventDefault();
          map.setView(map.getCenter(), map.getZoom() - 1, {animate: true});
        });

        return container;
      };
      zoomControl.addTo(map);

      let geoJsonLayers = [];
      let currentLayerIndex = 0;

      if (geojsonsString) {
        try {
          const geojsons = JSON.parse(geojsonsString);
          console.log('Parsed GeoJSONs:', geojsons);

          geoJsonLayers = geojsons.map(geojsonString => {
            try {
              const geojson = JSON.parse(geojsonString);
              console.log('Individual GeoJSON:', geojson);
              return L.geoJSON(geojson, {
                style: function (feature) {
                  return {
                    color: "#ff7800",
                    weight: 5,
                    opacity: 0.65
                  };
                },
                onEachFeature: function (feature, layer) {
                  if (feature.properties && feature.properties.popupContent) {
                    layer.bindPopup(feature.properties.popupContent);
                  }
                }
              });
            } catch (error) {
              console.error('Error parsing individual GeoJSON:', error);
              return null;
            }
          }).filter(layer => layer !== null);

          console.log('GeoJSON Layers:', geoJsonLayers);

          if (geoJsonLayers.length > 0) {
            geoJsonLayers[0].addTo(map);
            const group = L.featureGroup(geoJsonLayers);
            map.fitBounds(group.getBounds());
          }
        } catch (error) {
          console.error('Error parsing GeoJSONs:', error);
        }
      } else {
        console.log('No GeoJSONs found');
      }

      // Função para animar a transição entre camadas GeoJSON
      function animateToNextLayer() {
        if (geoJsonLayers.length <= 1) return;

        map.removeLayer(geoJsonLayers[currentLayerIndex]);
        currentLayerIndex = (currentLayerIndex + 1) % geoJsonLayers.length;
        map.addLayer(geoJsonLayers[currentLayerIndex]);

        map.fitBounds(geoJsonLayers[currentLayerIndex].getBounds(), {
          animate: true,
          duration: 1 // duração da animação em segundos
        });
      }

      // Função para verificar o scroll e animar para a próxima camada
      function checkScrollAndAnimate() {
        const mapRect = mapElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight;

        if (mapRect.top < viewportHeight && mapRect.bottom > 0) {
          animateToNextLayer();
        }
      }

      // Adiciona o evento de scroll
      window.addEventListener('scroll', checkScrollAndAnimate);

      // Função para redimensionar o mapa
      function resizeMap() {
        map.invalidateSize();
      }

      // Redimensiona o mapa quando a janela é redimensionada
      window.addEventListener('resize', resizeMap);

      // Redimensiona o mapa após um curto atraso para garantir que todos os elementos estejam carregados
      setTimeout(resizeMap, 250);
    });
  }

  // Initialize the map when the DOM is fully loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMap);
  } else {
    initMap();
  }
</script>
