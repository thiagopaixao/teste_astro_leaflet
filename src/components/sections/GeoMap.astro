---
interface Props {
  title: string;
  content: string;
  latitude: number;
  longitude: number;
  zoom: number;
  geojsons?: { geojson: string }[];
  id: string;
  typelayer: string;
}

const { title, content, latitude, longitude, zoom, geojsons, id, typelayer } = Astro.props;
---

<section class="relative w-full h-[600vh]">
  <div class="sticky top-0 w-full h-screen overflow-hidden">
    <div class="absolute inset-0 z-10 bg-black bg-opacity-50 flex flex-col justify-center items-center text-white p-4">
      <h2 class="text-3xl font-bold mb-4">{title}</h2>
      <div class="prose max-w-none mb-4 text-white" set:html={content} />
    </div>
    <div id={id} class="absolute inset-0 geo-map" data-latitude={latitude} data-longitude={longitude} data-zoom={zoom} data-geojsons={JSON.stringify(geojsons?.map(g => g.geojson))} data-typelayer={typelayer}></div>
  </div>
  <div class="h-[500vh]"></div>
</section>

<style>
  .prose :global(*) {
    color: white;
  }
</style>

<script>
  import L from 'leaflet';
  import 'leaflet/dist/leaflet.css';

  function initMap() {
    const mapElements = document.querySelectorAll('.geo-map');
    mapElements.forEach((mapElement) => {
      if (!mapElement) return;

      const latitude = Number(mapElement.dataset.latitude);
      const longitude = Number(mapElement.dataset.longitude);
      const zoom = Number(mapElement.dataset.zoom);
      const geojsonsString = mapElement.dataset.geojsons;

      const map = L.map(mapElement.id, {
        zoomControl: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        touchZoom: false,
        boxZoom: false,
        keyboard: false,
        zoomSnap: 0,
        zoomDelta: 0,
        dragging: false,
        minZoom: zoom,
        maxZoom: zoom
      }).setView([latitude, longitude], zoom);

      const mapTypes = {
        map: {
          url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        },
        topology: {
          url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
          attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        },
        satellite: {
          url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
          attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        }
      };

      const typelayer = mapElement.dataset.typelayer || 'map';
      const selectedMapType = mapTypes[typelayer];

      console.log(`Map ${mapElement.id} initialized with type: ${typelayer}`);

      // Adiciona um controle de camadas para alternar entre os tipos de mapa
      // Cria todas as camadas
      const baseLayers = {
        "Mapa": L.tileLayer(mapTypes.map.url, { attribution: mapTypes.map.attribution }),
        "Topografia": L.tileLayer(mapTypes.topology.url, { attribution: mapTypes.topology.attribution }),
        "Satélite": L.tileLayer(mapTypes.satellite.url, { attribution: mapTypes.satellite.attribution })
      };

      // Determina qual camada deve ser adicionada por padrão
      const defaultLayer = typelayer === 'map' ? "Mapa" : typelayer === 'topology' ? "Topografia" : "Satélite";

      // Adiciona a camada padrão ao mapa
      baseLayers[defaultLayer].addTo(map);

      // Adiciona o controle de camadas, marcando a camada padrão como selecionada
      const layerControl = L.control.layers(baseLayers, null, { position: 'topright' }).addTo(map);

      // Marca a camada padrão como selecionada no controle de camadas
      Object.keys(baseLayers).forEach(layerName => {
        if (layerName === defaultLayer) {
          map.addLayer(baseLayers[layerName]);
        } else {
          map.removeLayer(baseLayers[layerName]);
        }
      });

      let geoJsonLayers = [];
      let currentLayerIndex = -1;
      let isAnimating = false;
      let geojsons = [];

      if (geojsonsString) {
        try {
          geojsons = JSON.parse(geojsonsString);
          console.log('Parsed GeoJSONs:', geojsons);
        } catch (error) {
          console.error('Error parsing GeoJSONs:', error);
        }
      } else {
        console.log('No GeoJSONs found');
      }

      function loadGeoJsonLayer(index) {
        if (index >= 0 && index < geojsons.length) {
          try {
            const geojson = JSON.parse(geojsons[index]);
            console.log('Loading GeoJSON:', geojson);
            const layer = L.geoJSON(geojson, {
              style: function (feature) {
                return {
                  color: "#ff7800",
                  weight: 5,
                  opacity: 0.65
                };
              },
              onEachFeature: function (feature, layer) {
                if (feature.properties && feature.properties.popupContent) {
                  layer.bindPopup(feature.properties.popupContent);
                }
              }
            });
            geoJsonLayers[index] = layer;
            return layer;
          } catch (error) {
            console.error('Error parsing individual GeoJSON:', error);
            return null;
          }
        }
        return null;
      }

      // Função para animar a transição entre camadas GeoJSON
      function animateToLayer(targetIndex) {
        if (geojsons.length === 0 || isAnimating) return;

        isAnimating = true;

        // Remove a camada atual
        if (currentLayerIndex >= 0 && currentLayerIndex < geoJsonLayers.length && geoJsonLayers[currentLayerIndex]) {
          map.removeLayer(geoJsonLayers[currentLayerIndex]);
        }

        // Carrega e adiciona a nova camada
        const newLayer = loadGeoJsonLayer(targetIndex);
        if (newLayer) {
          map.addLayer(newLayer);

          // Ajusta a visualização para a nova camada
          map.fitBounds(newLayer.getBounds(), {
            animate: true,
            duration: 1.5,
            easeLinearity: 0.25,
          });

          currentLayerIndex = targetIndex;
        }

        setTimeout(() => {
          isAnimating = false;
        }, 1500);
      }

      // Função para verificar o scroll e animar para a próxima ou anterior camada
      function checkScrollAndAnimate() {
        const mapRect = mapElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const sectionHeight = mapElement.closest('section').offsetHeight;
        const scrollProgress = (window.pageYOffset - mapRect.top + viewportHeight) / sectionHeight;

        if (scrollProgress >= 0 && scrollProgress <= 1) {
          // Carrega o primeiro GeoJSON com maior atraso
          if (currentLayerIndex === -1 && scrollProgress >= 0.7) { // Aumentado de 0.5 para 0.7
            const firstLayer = loadGeoJsonLayer(0);
            if (firstLayer) {
              map.addLayer(firstLayer);
              currentLayerIndex = 0;
              console.log('First GeoJSON layer loaded');
            }
          } else if (currentLayerIndex >= 0) {
            const numLayers = geojsons.length;
            // Ajusta o cálculo para que o primeiro GeoJSON fique visível por mais tempo
            const firstLayerThreshold = 0.7; // Aumentado de 0.3 para 0.7
            const remainingScrollSpace = 1 - firstLayerThreshold;
            const segmentSize = remainingScrollSpace / (numLayers - 1);
            
            let targetIndex;
            if (scrollProgress < firstLayerThreshold) {
              targetIndex = 0;
            } else {
              targetIndex = Math.min(Math.max(1, Math.floor((scrollProgress - firstLayerThreshold) / segmentSize) + 1), numLayers - 1);
            }
            
            if (targetIndex !== currentLayerIndex) {
              console.log(`Transitioning to GeoJSON layer ${targetIndex}`);
              animateToLayer(targetIndex);
            }
          }
        }
      }

      // Adiciona o evento de scroll com throttle
      let lastKnownScrollPosition = 0;
      let ticking = false;

      function onScroll(scrollPos) {
        checkScrollAndAnimate();
      }

      window.addEventListener('scroll', function(e) {
        lastKnownScrollPosition = window.scrollY;

        if (!ticking) {
          window.requestAnimationFrame(function() {
            onScroll(lastKnownScrollPosition);
            ticking = false;
          });

          ticking = true;
        }
      });

      // Chama a função de animação inicialmente para garantir que a primeira camada seja exibida
      checkScrollAndAnimate();

      // Adiciona um listener para o evento 'resize' para recalcular quando a janela for redimensionada
      window.addEventListener('resize', checkScrollAndAnimate);

      // Função para redimensionar o mapa
      function resizeMap() {
        map.invalidateSize();
      }

      // Redimensiona o mapa quando a janela é redimensionada
      window.addEventListener('resize', resizeMap);

      // Redimensiona o mapa após um curto atraso para garantir que todos os elementos estejam carregados
      setTimeout(resizeMap, 250);
    });
  }

  // Initialize the map when the DOM is fully loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMap);
  } else {
    initMap();
  }
</script>
